//===- LerosISelDAGToDAG.cpp - A dag to dag inst selector for Leros ---===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the Leros target.
//
//===----------------------------------------------------------------------===//

#include "Leros.h"
#include "LerosTargetMachine.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/SelectionDAGNodes.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/Support/KnownBits.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

namespace llvm {

#define DEBUG_TYPE "leros-isel"

// Leros  specific code to select Leros machine
// instructions for SelectionDAG operations.
namespace {
class LerosDAGToDAGISel : public SelectionDAGISel {
  const LerosSubtarget *Subtarget;

public:
  LerosDAGToDAGISel(LerosTargetMachine &TM) : SelectionDAGISel(TM) {}

  StringRef getPassName() const {
    return "Leros DAG->DAG Pattern Instruction Selection";
  }

  void PostprocessISelDAG() override;

  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<LerosSubtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

  void Select(SDNode *N) override;

  bool SelectAddrFI(SDValue Addr, SDValue &Base);

public:
// Include the pieces autogenerated from the target description.
#include "LerosGenDAGISel.inc"

private:
  void doPeepholeLoadStoreADDI();
};
} // end anonymous namespace

void LerosDAGToDAGISel::PostprocessISelDAG() { doPeepholeLoadStoreADDI(); }

void LerosDAGToDAGISel::Select(SDNode *Node) {
  // If we have a custom node, we have already selected.
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  // Instruction Selection not handled by the auto-generated tablegen selection
  // should be handled here.
  unsigned Opcode = Node->getOpcode();
  MVT XLenVT = Subtarget->getXLenVT();
  SDLoc DL(Node);
  EVT VT = Node->getValueType(0);
  switch (Opcode) {
  case ISD::Constant: {
    auto ConstNode = cast<ConstantSDNode>(Node);
    auto immediate = ConstNode->getZExtValue();

    if (VT == XLenVT &&
        LEROSCREG::values.find(immediate) != LEROSCREG::values.end()) {
      SDValue New =
          CurDAG->getCopyFromReg(CurDAG->getEntryNode(), SDLoc(Node),
                                 LEROSCREG::values.at(immediate), XLenVT);
      ReplaceNode(Node, New.getNode());
      return;
    }
    break;
  }
  case ISD::FrameIndex: {
    SDValue Imm = CurDAG->getTargetConstant(0, DL, XLenVT);
    int FI = cast<FrameIndexSDNode>(Node)->getIndex();
    SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
    ReplaceNode(Node,
                CurDAG->getMachineNode(Leros::ADDI_PSEUDO, DL, VT, TFI, Imm));
    return;
  }
  }

  // Select the default instruction.
  SelectCode(Node);
}

bool LerosDAGToDAGISel::SelectAddrFI(SDValue Addr, SDValue &Base) {
  if (auto FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), Subtarget->getXLenVT());
    return true;
  }
  return false;
}

// Merge an ADD_PSEUDO into the offset of a load/store instruction where
// possible
void LerosDAGToDAGISel::doPeepholeLoadStoreADDI() {
  SelectionDAG::allnodes_iterator Position(CurDAG->getRoot().getNode());
  ++Position;

  while (Position != CurDAG->allnodes_begin()) {
    SDNode *N = &*--Position;
    // Skip dead nodes and any non-machine opcodes.
    if (N->use_empty() || !N->isMachineOpcode())
      continue;

    int OffsetOpIdx;
    int BaseOpIdx;

    // Attempt optimization for loads and stores
    switch (N->getMachineOpcode()) {
    default:
      continue;
    case Leros::LDINDBU_PSEUDO:
    case Leros::LDIND_PSEUDO:
      BaseOpIdx = 0;
      OffsetOpIdx = 1;
      break;
    case Leros::STINDB_PSEUDO:
    case Leros::STIND_PSEUDO:
      BaseOpIdx = 1;
      OffsetOpIdx = 2;
      break;
    }

    // Currently, the load/store offset must be 0 to be considered for this
    // peephole optimisation.
    if (!isa<ConstantSDNode>(N->getOperand(OffsetOpIdx)) ||
        N->getConstantOperandVal(OffsetOpIdx) != 0)
      continue;

    SDValue Base = N->getOperand(BaseOpIdx);

    // If the base is an ADDI_PSEUDO, we can merge it in to the load/store.
    if (!Base.isMachineOpcode() ||
        Base.getMachineOpcode() != Leros::ADDI_PSEUDO)
      continue;

    SDValue ImmOperand = Base.getOperand(1);

    if (auto Const = dyn_cast<ConstantSDNode>(ImmOperand)) {
      ImmOperand = CurDAG->getTargetConstant(
          Const->getSExtValue(), SDLoc(ImmOperand), ImmOperand.getValueType());
    } else if (auto GA = dyn_cast<GlobalAddressSDNode>(ImmOperand)) {
      ImmOperand = CurDAG->getTargetGlobalAddress(
          GA->getGlobal(), SDLoc(ImmOperand), ImmOperand.getValueType(),
          GA->getOffset(), GA->getTargetFlags());
    } else {
      continue;
    }

    LLVM_DEBUG(dbgs() << "Folding add-immediate into mem-op:\nBase:    ");
    LLVM_DEBUG(Base->dump(CurDAG));
    LLVM_DEBUG(dbgs() << "\nN: ");
    LLVM_DEBUG(N->dump(CurDAG));
    LLVM_DEBUG(dbgs() << "\n");

    // Modify the offset operand of the load/store.
    if (BaseOpIdx == 0) // Load
      CurDAG->UpdateNodeOperands(N, Base.getOperand(0), ImmOperand,
                                 N->getOperand(2));
    else // Store
      CurDAG->UpdateNodeOperands(N, N->getOperand(0), Base.getOperand(0),
                                 ImmOperand, N->getOperand(3));

    // The add-immediate may now be dead, in which case remove it.
    if (Base.getNode()->use_empty())
      CurDAG->RemoveDeadNode(Base.getNode());
  }
}
// Predicate function for the IsOrAdd PatFrag in LerosInstrInfo.td
// Checks if an OR operation is equivalent to an ADD operation.
// This is true if (A | B) == (A + B), which happens when (A & B) == 0.
bool isOrEquivalentToAdd(const SDNode *N, SelectionDAG &DAG) {
  // Ensure this is an OR node with two operands
  if (!N || N->getOpcode() != ISD::OR || N->getNumOperands() != 2)
    return false;

  SDValue Op0 = N->getOperand(0);
  SDValue Op1 = N->getOperand(1);

  // Use KnownBits analysis to check if the operands' set bits might overlap.
  // If we know that (Op0 & Op1) == 0, then OR is equivalent to ADD.
  KnownBits KnownOp0 = DAG.computeKnownBits(Op0);
  KnownBits KnownOp1 = DAG.computeKnownBits(Op1);

  // Check if the bits known to be zero in one operand cover all the bits
  // possibly set in the other operand.
  if ((KnownOp0.Zero | KnownOp1.Zero).isAllOnes()) {
    // If the union of zero bits covers the entire width,
    // then (A & B) must be 0.
    return true;
  }

  // A simpler, less precise check:
  // if ((KnownOp0.One & KnownOp1.One).isZero()) {
  //    // If there are no bits known to be set in *both* operands,
  //    // they *might* be non-overlapping. This isn't strictly sufficient
  //    // on its own but can be part of the check.
  //    // return true; // Potentially, needs more checks
  // }


  // Fallback: If KnownBits analysis is inconclusive, assume they might overlap.
  LLVM_DEBUG(dbgs() << "isOrEquivalentToAdd: KnownBits inconclusive for node: "; N->dump(&DAG); dbgs() << "\n");
  return false;
}
} // namespace llvm

/// createLerosISelDag - This pass converts a Lerosalized DAG into a
/// Leros-specific DAG, ready for instruction scheduling.
///
namespace {
// Legacy wrapper class to provide a FunctionPass interface
class LerosDAGToDAGISelLegacy : public llvm::SelectionDAGISelLegacy {
public:
  static char ID;
  explicit LerosDAGToDAGISelLegacy(llvm::LerosTargetMachine &TM)
      : SelectionDAGISelLegacy(ID, std::make_unique<llvm::LerosDAGToDAGISel>(TM)) {}
};
} // end anonymous namespace

char LerosDAGToDAGISelLegacy::ID = 0;

llvm::FunctionPass *llvm::createLerosISelDag(LerosTargetMachine &TM) {
  return new LerosDAGToDAGISelLegacy(TM);
}